// Generated by CoffeeScript 1.3.3
(function() {
  var Grid, GridView,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Grid = (function(_super) {

    __extends(Grid, _super);

    function Grid() {
      return Grid.__super__.constructor.apply(this, arguments);
    }

    Grid.prototype.defaults = {
      blocks: null,
      regions: null,
      data: null
    };

    Grid.prototype.regionsChangedTimeout = null;

    Grid.prototype.initialize = function() {
      this.get("blocks").on("contentReset", this.contentReset, this);
      this.get("regions").on("change:active", this.regionsChange, this);
      this.get("blocks").on("change:placed", this.blockPlacedChange, this);
      this.get("blocks").on("dropped", this.blockDropped, this);
      return this.set({
        "data": new Array(config.grid_size.x * config.grid_size.y)
      });
    };

    Grid.prototype.contentReset = function() {
      this.emptyGrid();
      return this.update();
    };

    Grid.prototype.update = function() {
      this.fillWithBlocks();
      this.trigger("change:data");
      return this.get("blocks").setBlocksToGridPositions(this.getGridPositions());
    };

    Grid.prototype.regionsChange = function(model, value) {
      var that;
      that = this;
      clearTimeout(this.regionsChangedTimeout);
      return this.regionsChangedTimeout = setTimeout(function() {
        var active, activeRegions, region, _i, _len;
        active = that.get('regions').getActiveRegions();
        console.log("regions", _.map(active, function(element) {
          return element.get('position');
        }));
        that.get("blocks").each(function(element, index) {
          return element.set({
            "placed": false
          });
        });
        that.emptyGrid();
        activeRegions = that.get('regions').getActiveRegions();
        for (_i = 0, _len = activeRegions.length; _i < _len; _i++) {
          region = activeRegions[_i];
          that.setRegion(region);
        }
        return that.update();
      }, 0);
    };

    Grid.prototype.blockPlacedChange = function(model, value) {
      var position;
      if (value === false) {
        console.log("unplaced", model);
        position = model.get("position");
        this.empty(position.x, position.y);
        return this.trigger("change:data");
      }
    };

    Grid.prototype.blockDropped = function(block) {
      var position, size;
      console.log("Grid.blockDropped", block);
      position = block.get("position");
      size = block.get("size");
      if (this.isDroppedOnRegion(block)) {
        console.warn("dropped on region");
        block.open();
      } else {
        block.close();
        this.setBlock(position.x, position.y, size);
        this.trigger("change:data");
      }
      return this.findNearestPositionForNonPlacedBlocks(position);
    };

    Grid.prototype.val = function(x, y) {
      var data;
      if (x < 0 || y < 0 || x > config.grid_size.x - 1 || y > config.grid_size.y - 1) {
        return false;
      }
      data = this.get("data");
      return data[y * config.grid_size.x + x];
    };

    Grid.prototype.empty = function(x, y) {
      if (this.val(x, y) === "B") {
        this.setVal(x, y, ".");
        this.setVal(x + 1, y, ".");
        this.setVal(x, y + 1, ".");
        return this.setVal(x + 1, y + 1, ".");
      } else if (this.val(x, y) === "S") {
        return this.setVal(x, y, ".");
      }
    };

    Grid.prototype.isEmpty = function(x, y, big) {
      if (big == null) {
        big = false;
      }
      if (big) {
        if (this.val(x, y) === false || this.val(x + 1, y) === false || this.val(x, y + 1) === false || this.val(x + 1, y + 1) === false) {
          return false;
        }
        return this.isEmpty(x, y) && this.isEmpty(x + 1, y) && this.isEmpty(x, y + 1) && this.isEmpty(x + 1, y + 1);
      } else {
        if (this.val(x, y) === false) {
          return false;
        }
        return this.val(x, y) === "." || this.val(x, y) === "";
      }
    };

    Grid.prototype.isDroppedOnRegion = function(block) {
      var x, y;
      x = block.get("position").x;
      y = block.get("position").y;
      if (block.get("size") === BIG) {
        if (this.val(x, y).toLowerCase() === "r" || this.val(x + 1, y).toLowerCase() === "r" || this.val(x, y + 1).toLowerCase() === "r" || this.val(x + 1, y + 1).toLowerCase() === "r") {
          return true;
        }
      } else {
        if (this.val(x, y).toLowerCase() === "r") {
          return true;
        }
      }
      return false;
    };

    Grid.prototype.setVal = function(x, y, value) {
      var data;
      data = this.get("data");
      data[y * config.grid_size.x + x] = value;
      return this.set({
        "data": data
      });
    };

    Grid.prototype.getRandomEmptySpot = function(big) {
      var index_x, index_y, range, range_x, range_y, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _results, _results1;
      range_x = _.shuffle((function() {
        _results = [];
        for (var _i = 0, _ref = config.grid_size.x - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this));
      range_y = _.shuffle((function() {
        _results1 = [];
        for (var _j = 0, _ref1 = config.grid_size.y - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; 0 <= _ref1 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this));
      range = [];
      for (_k = 0, _len = range_x.length; _k < _len; _k++) {
        index_x = range_x[_k];
        for (_l = 0, _len1 = range_y.length; _l < _len1; _l++) {
          index_y = range_y[_l];
          x = range_x[index_x];
          y = range_y[index_y];
          range.push({
            "x": x,
            "y": y
          });
        }
      }
      return this.getEmptySpot(range, big);
    };

    Grid.prototype.findFreeSpotCloseTo = function(center, big) {
      var d2, dx, dy, index_x, index_y, range, range_x, range_y, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _results, _results1;
      range_x = (function() {
        _results = [];
        for (var _i = 0, _ref = config.grid_size.x - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      range_y = (function() {
        _results1 = [];
        for (var _j = 0, _ref1 = config.grid_size.y - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; 0 <= _ref1 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this);
      range = [];
      for (_k = 0, _len = range_x.length; _k < _len; _k++) {
        index_x = range_x[_k];
        for (_l = 0, _len1 = range_y.length; _l < _len1; _l++) {
          index_y = range_y[_l];
          x = range_x[index_x];
          y = range_y[index_y];
          dx = x - center.x;
          dy = y - center.y;
          d2 = dx * dx + dy * dy;
          range.push({
            "x": x,
            "y": y,
            "d2": d2
          });
        }
      }
      range = _.sortBy(range, "d2");
      console.log("findFreeSpotCloseTo", range, big);
      return this.getEmptySpot(range, big);
    };

    Grid.prototype.getEmptySpot = function(range, big) {
      var position, tries, x, y, _i, _len;
      tries = [];
      for (_i = 0, _len = range.length; _i < _len; _i++) {
        position = range[_i];
        x = position.x;
        y = position.y;
        tries.push("(" + x + "," + y + ")");
        if (this.isEmpty(x, y, big)) {
          return {
            "x": x,
            "y": y
          };
        }
      }
      return false;
    };

    Grid.prototype.findRangeClosest = function(center, size) {
      var i, longest, range, range_l, range_r, shortest, _i, _j, _k, _ref, _ref1, _results, _results1;
      range_l = (function() {
        _results = [];
        for (var _i = center; center <= 0 ? _i <= 0 : _i >= 0; center <= 0 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      range_r = (function() {
        _results1 = [];
        for (var _j = center, _ref = size - 1; center <= _ref ? _j <= _ref : _j >= _ref; center <= _ref ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this);
      range = [];
      shortest = range_l.length > range_r.length ? range_r : range_l;
      longest = range_l.length > range_r.length ? range_l : range_r;
      for (i = _k = 0, _ref1 = shortest.length * 2 - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        range[i] = i % 2 === 0 ? range_l[i / 2] : range_r[(i - 1) / 2];
      }
      range = range.concat(_.rest(longest, shortest.length));
      return range = _.rest(range, 1);
    };

    Grid.prototype.setRegion = function(region) {
      var i, j, size_x, size_y, x, y, _i, _j, _ref, _ref1;
      x = config.region_positions[region.get("position")].x;
      y = config.region_positions[region.get("position")].y;
      x = Math.max(0, Math.min(x, config.grid_size.x - config.region_size.x));
      y = Math.max(0, Math.min(y, config.grid_size.y - config.region_size.y));
      size_x = x + config.region_size.x;
      size_y = y + config.region_size.y;
      for (i = _i = x, _ref = size_x - 1; x <= _ref ? _i <= _ref : _i >= _ref; i = x <= _ref ? ++_i : --_i) {
        for (j = _j = y, _ref1 = size_y - 1; y <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = y <= _ref1 ? ++_j : --_j) {
          this.setVal(i, j, "r");
        }
      }
      return this.setVal(x, y, "R");
    };

    Grid.prototype.setBlock = function(x, y, size) {
      if (size == null) {
        size = BIG;
      }
      if (size === BIG) {
        x = Math.max(0, Math.min(x, config.grid_size.x - 2));
        y = Math.max(0, Math.min(y, config.grid_size.y - 2));
        this.setVal(x, y, "B");
        this.setVal(x + 1, y, "b");
        this.setVal(x, y + 1, "b");
        return this.setVal(x + 1, y + 1, "b");
      } else if (size === SMALL) {
        x = Math.max(0, Math.min(x, config.grid_size.x - 1));
        y = Math.max(0, Math.min(y, config.grid_size.y - 1));
        return this.setVal(x, y, "S");
      }
    };

    Grid.prototype.emptyGrid = function() {
      var data, i, _i, _ref;
      console.log("emptyGrid");
      data = new Array();
      for (i = _i = 0, _ref = config.grid_size.x * config.grid_size.y - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        data[i] = ".";
      }
      return this.set({
        "data": data
      });
    };

    Grid.prototype.fillWithBlocks = function() {
      var alreadyPlaced, bigBlocks, blocks, i, maxFreeBig, maxFreeSmall, smallBlocks, spot, _i, _j, _ref, _ref1, _results;
      blocks = this.get("blocks").getBlocksOrdered(true);
      if (blocks.length === 0) {
        return;
      }
      alreadyPlaced = this.get("blocks").length - blocks.length;
      maxFreeBig = Math.min(blocks.length, this.freeBigSpots());
      maxFreeSmall = this.freeSmallSpots();
      bigBlocks = Math.min(blocks.length, Math.floor((maxFreeSmall - blocks.length) / (4 - 1)));
      smallBlocks = Math.max(0, Math.min(blocks.length - bigBlocks, maxFreeSmall - bigBlocks * 4));
      console.log("fill with blocks", "big: " + bigBlocks, "small: " + smallBlocks);
      for (i = _i = 0, _ref = bigBlocks - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        spot = this.getRandomEmptySpot(true);
        if (spot !== false) {
          this.setBlock(spot.x, spot.y, BIG);
        } else {
          console.log("not enough free big spots found");
          bigBlocks = i;
          break;
        }
      }
      smallBlocks = blocks.length - bigBlocks;
      _results = [];
      for (i = _j = 0, _ref1 = smallBlocks - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        spot = this.getRandomEmptySpot();
        if (spot !== false) {
          _results.push(this.setBlock(spot.x, spot.y, SMALL));
        } else {
          console.log("not enough free small spots found");
          break;
        }
      }
      return _results;
    };

    Grid.prototype.findNearestPositionForNonPlacedBlocks = function(center) {
      var block, nonPlacedBlocks, position, _i, _len, _results;
      nonPlacedBlocks = this.get("blocks").getNonPlacedBlocks();
      _results = [];
      for (_i = 0, _len = nonPlacedBlocks.length; _i < _len; _i++) {
        block = nonPlacedBlocks[_i];
        position = this.findFreeSpotCloseTo(center, block.get("size") === BIG);
        if (position === false) {
          console.warn("cannot find big spot, shrink the block");
          block.set({
            "size": SMALL
          });
          position = this.findFreeSpotCloseTo(center, block.get("size") === BIG);
        }
        this.setBlock(position.x, position.y, block.get("size"));
        this.trigger("change:data");
        _results.push(block.place(position));
      }
      return _results;
    };

    Grid.prototype.clearRegions = function() {
      var x, y, _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = config.grid_size.y - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = config.grid_size.x - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            if (x % 2 === 0 & y % 2 === 0) {
              _results1.push(this.setVal(x, y, "B"));
            } else {
              _results1.push(this.setVal(x, y, "b"));
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Grid.prototype.freeSmallSpots = function() {
      return (config.grid_size.x * config.grid_size.y) - this.numActiveRegions() * (config.region_size.x * config.region_size.y);
    };

    Grid.prototype.freeBigSpots = function() {
      var bottom, top;
      top = this.get('regions').active_top;
      bottom = this.get('regions').active_bottom;
      if (top === 0 && bottom === 0) {
        return 28;
      }
      if (top === 0 && bottom === 1) {
        return 2 * 8 + 6;
      }
      if (top === 0 && bottom === 2) {
        return 2 * 6 + 4;
      }
      if (top === 1 && bottom === 0) {
        return 2 * 8 + 6;
      }
      if (top === 1 && bottom === 1) {
        return 2 * 8 + 3;
      }
      if (top === 1 && bottom === 2) {
        return 2 * 4 + 4;
      }
      if (top === 2 && bottom === 0) {
        return 2 * 6 + 4;
      }
      if (top === 2 && bottom === 1) {
        return 2 * 4 + 4;
      }
      if (top === 2 && bottom === 2) {
        return 2 * 3 + 4;
      }
    };

    Grid.prototype.getGridPositions = function() {
      var positions, value, x, y, _i, _j, _ref, _ref1;
      positions = [];
      for (x = _i = 0, _ref = config.grid_size.x - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = config.grid_size.y - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          value = this.val(x, y);
          if (_.include(["B", "S"], value)) {
            positions.push({
              "x": x,
              "y": y,
              "value": value
            });
          }
        }
      }
      return positions;
    };

    Grid.prototype.numActiveRegions = function() {
      return this.get('regions').getActiveRegions().length;
    };

    return Grid;

  })(Backbone.Model);

  GridView = (function(_super) {

    __extends(GridView, _super);

    function GridView() {
      return GridView.__super__.constructor.apply(this, arguments);
    }

    GridView.prototype.className = "grid";

    GridView.prototype.id = "gridView";

    GridView.prototype.initialize = function() {
      _.bindAll(this);
      this.model.on("change:data", this.render, this);
      return this.$el.insertAfter($("#page"));
    };

    GridView.prototype.render = function() {
      var cell, row, table, x, y, _i, _j, _ref, _ref1;
      table = $("<table></table>");
      for (y = _i = 0, _ref = config.grid_size.y - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        row = $("<tr></tr>");
        table.append(row);
        for (x = _j = 0, _ref1 = config.grid_size.x - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          cell = $("<td class='col-" + x + " row-" + y + "' id='cell-" + x + "-" + y + "'></td>");
          cell.html(this.model.val(x, y));
          row.append(cell);
        }
      }
      this.$el.html(table);
      return this;
    };

    return GridView;

  })(Backbone.View);

  window.Grid = Grid;

  window.GridView = GridView;

}).call(this);
